#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
from nav_msgs.msg import Odometry
from std_msgs.msg import Header
from hippo_msgs.msg import ModemOut
from acoustic_simulator.acoustic_sim_class import acousticSimulation

import threading
import json


class SimulateAnchorMeasurementsNode(Node):

    def __init__(self, node_name):
        super().__init__(node_name=node_name)

        self.declare_parameter('acoustic_config_path',
                               rclpy.Parameter.Type.STRING)
        self.acoustic_config_path = str(
            self.get_parameter('acoustic_config_path').value)

        f = open(self.acoustic_config_path)
        self.config = json.load(f)
        f.close()

        self.number_anchor_modems = 4

        self.lock = threading.RLock()
        self.position = [
            0.0, 0.0, 0.0
        ]  # Alles fÃ¼r Hydrophon Position machen? -> In dem Fall Odometry Subscriber unten anpassen!
        self.velocity = [0.0, 0.0, 0.0]  # hier auch Hydrophon dann

        self.rate_accoustics = 1000  # Hz
        self.acoustic_sim = acousticSimulation(config=self.config)

        self.modem_pub = self.create_publisher(ModemOut,
                                               'modems',
                                               qos_profile=1)

        self.modem_publisher_list = []
        for i in range(self.number_anchor_modems):
            topic_name = 'modem_' + str(
                i + 1)  # TODO: fix modem ids starting at 1
            pub = self.create_publisher(ModemOut, topic_name, qos_profile=1)
            self.modem_publisher_list.append(pub)

        self.modem_error_publisher_list = []
        for i in range(self.number_anchor_modems):
            topic_name = 'modem_error' + str(i + 1)
            pub = self.create_publisher(ModemOut, topic_name, qos_profile=1)
            self.modem_error_publisher_list.append(pub)

        self.odometry_sub = self.create_subscription(Odometry,
                                                     'odometry',
                                                     self.on_odometry,
                                                     qos_profile=1)

        self.acoustics_timer = self.create_timer(
            timer_period_sec=(1 / self.rate_accoustics),
            callback=self.simulate_acoustics)

    def simulate_acoustics(self):
        t = self.get_clock().now()
        t = t.nanoseconds * 1e-9  # convert time to nanoseconds

        with self.lock:
            # What about moving buoys etc?
            measurement = self.acoustic_sim.simulate(self.position, t)

            if measurement is None:
                return

            self.send_measurement(measurement["ModemID"], measurement["dist"],
                                  measurement["time_published"])

    def on_odometry(self, msg: Odometry):
        p = msg.pose.pose.position
        v = msg.twist.twist.linear
        with self.lock:
            self.position = [p.x, p.y, p.z]
            self.velocity = [v.x, v.y, v.z]

    def send_measurement(self, id: int, dist: float, t: float):
        msg = ModemOut()
        msg.header = self.fill_header_timestamp(t)
        msg.distance = dist
        msg.id = id

        # publish all measurements in same topic
        self.modem_pub.publish(msg)

        # publish measurement in modem-specific topic
        self.modem_publisher_list[id - 1].publish(msg)

    def send_distance_error(self, id: int, err: float, t: float):
        # TODO: add 'error' entry to ModemOut instead
        msg = ModemOut()
        msg.header = self.fill_header_timestamp(t)
        msg.distance = err
        msg.id = id

        self.modem_error_publisher_list[id - 1].publish(msg)

    def fill_header_timestamp(self, t):
        # convert float seconds to int seconds + int nanoseconds
        # to be compatible with time stamp msg type
        header = Header()
        header.stamp.sec = int(t)
        header.stamp.nanosec = int((t - int(t)) * 1e9)
        return header


def main():
    rclpy.init()
    node = SimulateAnchorMeasurementsNode("acoustic_sim_test_node")
    rclpy.spin(node)


if __name__ == "__main__":
    main()
